#!/bin/bash
#
# aws-billing - AWS Cost Explorer billing viewer
#
# Shows detailed billing information for the current AWS profile
#

# Colors
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
RED='\033[0;31m'
MAGENTA='\033[0;35m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
NC='\033[0m' # No Color
BOLD='\033[1m'
DIM='\033[2m'

# Box drawing characters
BOX_TL="╔"
BOX_TR="╗"
BOX_BL="╚"
BOX_BR="╝"
BOX_H="═"
BOX_V="║"
BOX_ML="╠"
BOX_MR="╣"

# Default values
PERIOD="month"  # month, week, or custom
AWS_PROFILE_OPT=""  # Will be set to "--profile NAME" if specified

# Format: profile|account_id (same as awsp)
AWS_BILLING_PROFILES=(
    "busuu|331868046896"
    "busuu-prod|526745048846"
    "busuu-non-prod|841596778795"
    "busuu-sandbox|543227299426"
    "chegg-aws-busuu-verbling-nonprod|852617132818"
    "verbling|614942315762"
)

list_profiles() {
    local current
    current=$(get_current_profile)
    echo -e "AWS Profiles:\n"
    printf "  %-3s %-35s %s\n" "" "PROFILE" "ACCOUNT_ID"
    printf "  %-3s %-35s %s\n" "" "-------" "----------"
    for entry in "${AWS_BILLING_PROFILES[@]}"; do
        local profile="${entry%%|*}"
        local account_id="${entry##*|}"
        if [[ "$profile" == "$current" ]]; then
            printf "  ${GREEN}*${NC} ${YELLOW}%-35s${NC} %s\n" "$profile" "$account_id"
        else
            printf "    %-35s %s\n" "$profile" "$account_id"
        fi
    done
}

show_help() {
    echo -e "${BOLD}Usage:${NC} aws-billing [OPTIONS]"
    echo ""
    echo "Display AWS billing costs for the current profile"
    echo ""
    echo -e "${BOLD}Commands:${NC}"
    echo "  list                List available AWS profiles (current marked with *)"
    echo ""
    echo -e "${BOLD}Options:${NC}"
    echo "  -p, --profile NAME    AWS profile to use (default: current AWS_PROFILE)"
    echo "  -m, --mtd             Month-to-date costs (default)"
    echo "  -w, --week            Last 7 days costs"
    echo "  -y, --yesterday       Yesterday's costs"
    echo "  -d, --days N          Last N days costs"
    echo "  -f, --forecast        Include month-end forecast"
    echo "  -e, --ec2             Show detailed EC2 breakdown (default: enabled)"
    echo "  --no-ec2              Hide detailed EC2 breakdown"
    echo "  -t, --top N           Show top N services (default: 15)"
    echo "  -h, --help            Show this help message"
    echo ""
    echo -e "${BOLD}Examples:${NC}"
    echo "  aws-billing                     # Show help"
    echo "  aws-billing list                # List available profiles"
    echo "  aws-billing -p busuu-prod       # Show costs for busuu-prod profile"
    echo "  aws-billing -p busuu-sandbox -w # Show last 7 days for sandbox"
    echo "  aws-billing -d 30               # Show last 30 days"
    echo "  aws-billing -f                  # Include forecast"
    echo "  aws-billing --no-ec2            # Hide EC2 breakdown"
}

print_header() {
    local title="$1"
    local width=70
    local padding=$(( (width - ${#title} - 2) / 2 ))
    
    echo ""
    echo -e "${CYAN}${BOX_TL}$(printf '%*s' $width '' | tr ' ' "$BOX_H")${BOX_TR}${NC}"
    echo -e "${CYAN}${BOX_V}${NC}$(printf '%*s' $padding '')${BOLD}${WHITE} $title ${NC}$(printf '%*s' $((width - padding - ${#title} - 2)) '')${CYAN}${BOX_V}${NC}"
    echo -e "${CYAN}${BOX_BL}$(printf '%*s' $width '' | tr ' ' "$BOX_H")${BOX_BR}${NC}"
}

print_separator() {
    echo -e "${GRAY}$(printf '%72s' '' | tr ' ' '─')${NC}"
}

format_currency() {
    local amount="$1"
    printf "$%.2f" "$amount"
}

get_current_profile() {
    # Check for AWS_PROFILE environment variable first
    if [[ -n "$AWS_PROFILE" ]]; then
        echo "$AWS_PROFILE"
    elif [[ -n "$AWS_DEFAULT_PROFILE" ]]; then
        echo "$AWS_DEFAULT_PROFILE"
    else
        echo "default"
    fi
}

get_account_info() {
    local account_id
    local account_alias
    
    account_id=$(aws $AWS_PROFILE_OPT sts get-caller-identity --query 'Account' --output text 2>/dev/null)
    if [[ $? -ne 0 ]]; then
        echo ""
        return 1
    fi
    
    # Try to get account alias
    account_alias=$(aws $AWS_PROFILE_OPT iam list-account-aliases --query 'AccountAliases[0]' --output text 2>/dev/null)
    if [[ "$account_alias" == "None" ]] || [[ -z "$account_alias" ]]; then
        account_alias=""
    fi
    
    echo "$account_id|$account_alias"
}

calculate_dates() {
    local period="$1"
    local start_date end_date
    
    case "$period" in
        month|mtd)
            start_date=$(date -v1d +%Y-%m-%d 2>/dev/null || date -d "$(date +%Y-%m-01)" +%Y-%m-%d)
            end_date=$(date +%Y-%m-%d)
            ;;
        week)
            start_date=$(date -v-7d +%Y-%m-%d 2>/dev/null || date -d "7 days ago" +%Y-%m-%d)
            end_date=$(date +%Y-%m-%d)
            ;;
        yesterday)
            start_date=$(date -v-1d +%Y-%m-%d 2>/dev/null || date -d "yesterday" +%Y-%m-%d)
            end_date=$(date +%Y-%m-%d)
            ;;
        *)
            # Assume it's a number of days
            if [[ "$period" =~ ^[0-9]+$ ]]; then
                start_date=$(date -v-${period}d +%Y-%m-%d 2>/dev/null || date -d "${period} days ago" +%Y-%m-%d)
                end_date=$(date +%Y-%m-%d)
            else
                echo "Invalid period: $period" >&2
                return 1
            fi
            ;;
    esac
    
    echo "$start_date|$end_date"
}

get_costs_by_service() {
    local start_date="$1"
    local end_date="$2"
    
    aws $AWS_PROFILE_OPT ce get-cost-and-usage \
        --time-period Start="$start_date",End="$end_date" \
        --granularity MONTHLY \
        --metrics "UnblendedCost" \
        --group-by Type=DIMENSION,Key=SERVICE \
        --output json 2>/dev/null
}

get_total_cost() {
    local start_date="$1"
    local end_date="$2"
    
    aws $AWS_PROFILE_OPT ce get-cost-and-usage \
        --time-period Start="$start_date",End="$end_date" \
        --granularity MONTHLY \
        --metrics "UnblendedCost" \
        --output json 2>/dev/null
}

get_forecast() {
    local start_date end_date
    
    # Forecast from today to end of month
    start_date=$(date +%Y-%m-%d)
    # Get last day of current month
    end_date=$(date -v1d -v+1m -v-1d +%Y-%m-%d 2>/dev/null || date -d "$(date +%Y-%m-01) +1 month -1 day" +%Y-%m-%d)
    
    # Add one day to end_date for the API (it's exclusive)
    end_date=$(date -j -v+1d -f "%Y-%m-%d" "$end_date" +%Y-%m-%d 2>/dev/null || date -d "$end_date +1 day" +%Y-%m-%d)
    
    aws $AWS_PROFILE_OPT ce get-cost-forecast \
        --time-period Start="$start_date",End="$end_date" \
        --metric UNBLENDED_COST \
        --granularity MONTHLY \
        --output json 2>/dev/null
}

get_ec2_compute_breakdown() {
    local start_date="$1"
    local end_date="$2"
    
    aws $AWS_PROFILE_OPT ce get-cost-and-usage \
        --time-period Start="$start_date",End="$end_date" \
        --granularity MONTHLY \
        --metrics "UnblendedCost" \
        --filter '{"Dimensions": {"Key": "SERVICE", "Values": ["Amazon Elastic Compute Cloud - Compute"]}}' \
        --group-by Type=DIMENSION,Key=USAGE_TYPE \
        --output json 2>/dev/null
}

get_ec2_other_breakdown() {
    local start_date="$1"
    local end_date="$2"
    
    aws $AWS_PROFILE_OPT ce get-cost-and-usage \
        --time-period Start="$start_date",End="$end_date" \
        --granularity MONTHLY \
        --metrics "UnblendedCost" \
        --filter '{"Dimensions": {"Key": "SERVICE", "Values": ["EC2 - Other"]}}' \
        --group-by Type=DIMENSION,Key=USAGE_TYPE \
        --output json 2>/dev/null
}

display_ec2_breakdown() {
    local json_data="$1"
    local ec2_total="$2"
    local breakdown_title="$3"
    
    if [[ -z "$json_data" ]] || [[ "$json_data" == "null" ]]; then
        return
    fi
    
    # Parse EC2 usage types and categorize using Python (avoids bash associative arrays)
    local categorized_data
    categorized_data=$(echo "$json_data" | python3 -c "
import sys
import json
import re

def categorize_ec2_usage(usage_type):
    # Extract instance type pattern
    instance_pattern = r'[a-z][0-9]+[a-z]*\.[a-z0-9]+'
    
    if 'BoxUsage' in usage_type or 'HostBoxUsage' in usage_type:
        match = re.search(instance_pattern, usage_type)
        if match:
            return f'EC2 Instance ({match.group()})'
        return 'EC2 Instances'
    elif 'SpotUsage' in usage_type:
        match = re.search(instance_pattern, usage_type)
        if match:
            return f'Spot Instance ({match.group()})'
        return 'Spot Instances'
    elif 'EBS:VolumeUsage' in usage_type or 'EBS:Volume' in usage_type:
        # Check for volume type
        if 'gp3' in usage_type:
            return 'EBS Volumes (gp3)'
        elif 'gp2' in usage_type:
            return 'EBS Volumes (gp2)'
        elif 'io1' in usage_type or 'io2' in usage_type:
            return 'EBS Volumes (io1/io2)'
        return 'EBS Volumes'
    elif 'EBS:Snapshot' in usage_type:
        return 'EBS Snapshots'
    elif 'VolumeIOUsage' in usage_type or 'IOPS' in usage_type:
        return 'EBS IOPS'
    elif 'DataTransfer' in usage_type and ('In-Bytes' in usage_type):
        return 'Data Transfer In'
    elif 'DataTransfer' in usage_type and ('Out-Bytes' in usage_type):
        return 'Data Transfer Out'
    elif 'DataTransfer' in usage_type or 'InterZone' in usage_type:
        return 'Data Transfer (Regional)'
    elif 'ElasticIP' in usage_type or 'IdleAddress' in usage_type:
        return 'Elastic IPs'
    elif 'NatGateway' in usage_type:
        if 'Hours' in usage_type:
            return 'NAT Gateway (Hours)'
        elif 'Bytes' in usage_type:
            return 'NAT Gateway (Data)'
        return 'NAT Gateway'
    elif 'LoadBalancer' in usage_type or 'LCU' in usage_type:
        return 'Load Balancer'
    elif 'CW:' in usage_type:
        return 'CloudWatch (EC2)'
    elif 'CPUCredits' in usage_type:
        return 'CPU Credits'
    else:
        # Clean up and return
        cleaned = re.sub(r'^[A-Z][A-Z0-9]*-', '', usage_type)
        return cleaned[:35] if len(cleaned) > 35 else cleaned

data = json.load(sys.stdin)
categories = {}

for result in data.get('ResultsByTime', []):
    for group in result.get('Groups', []):
        usage_type = group['Keys'][0]
        cost = float(group['Metrics']['UnblendedCost']['Amount'])
        if cost > 0.01:
            category = categorize_ec2_usage(usage_type)
            categories[category] = categories.get(category, 0) + cost

# Sort by cost descending and print top 10
sorted_cats = sorted(categories.items(), key=lambda x: x[1], reverse=True)[:10]
for cat, cost in sorted_cats:
    print(f'{cost:.4f}|{cat}')
" 2>/dev/null)
    
    if [[ -z "$categorized_data" ]]; then
        return
    fi
    
    echo -e "  ${CYAN}┌─ ${BOLD}${breakdown_title}${NC}"
    echo -e "  ${CYAN}│${NC}"
    
    while IFS='|' read -r cost category; do
        local percentage
        percentage=$(echo "scale=2; ($cost / $ec2_total) * 100" | bc 2>/dev/null || echo "0")
        local color
        color=$(color_for_cost "$cost")
        
        # Create mini bar based on percentage (max 15 chars width)
        local bar_width=15
        local filled=$(echo "scale=0; ($percentage * $bar_width) / 100" | bc)
        
        # Ensure at least 1 block if percentage > 1%
        if (( $(echo "$percentage > 1" | bc -l) )) && [[ $filled -lt 1 ]]; then
            filled=1
        fi
        if [[ $filled -gt $bar_width ]]; then filled=$bar_width; fi
        if [[ $filled -lt 0 ]]; then filled=0; fi
        
        local bar=""
        for ((i=0; i<filled; i++)); do bar+="▓"; done
        for ((i=filled; i<bar_width; i++)); do bar+="░"; done
        
        # Truncate category name if too long
        local display_cat="$category"
        if [[ ${#display_cat} -gt 30 ]]; then
            display_cat="${display_cat:0:27}..."
        fi
        
        printf "  ${CYAN}│${NC}   %-32s ${color}%10.2f${NC} %6.1f%%  ${MAGENTA}%s${NC}\n" "$display_cat" "$cost" "$percentage" "$bar"
        
    done <<< "$categorized_data"
    
    echo -e "  ${CYAN}└─────────────────────────────────────────────────────────────────────${NC}"
}

color_for_cost() {
    local cost="$1"
    local threshold_low=10
    local threshold_med=100
    local threshold_high=500
    
    if (( $(echo "$cost < $threshold_low" | bc -l) )); then
        echo "$GREEN"
    elif (( $(echo "$cost < $threshold_med" | bc -l) )); then
        echo "$YELLOW"
    elif (( $(echo "$cost < $threshold_high" | bc -l) )); then
        echo "$MAGENTA"
    else
        echo "$RED"
    fi
}

create_bar() {
    local percentage="$1"
    local width=20
    
    # Calculate filled blocks based on percentage (0-100)
    # Multiply first, then divide to avoid truncation issues with bc
    local filled=$(echo "scale=0; ($percentage * $width) / 100" | bc)
    
    # Ensure at least 1 block if percentage > 0.5%
    if (( $(echo "$percentage > 0.5" | bc -l) )) && [[ $filled -lt 1 ]]; then
        filled=1
    fi
    
    if [[ $filled -gt $width ]]; then
        filled=$width
    fi
    if [[ $filled -lt 0 ]]; then
        filled=0
    fi
    
    local bar=""
    for ((i=0; i<filled; i++)); do
        bar+="█"
    done
    for ((i=filled; i<width; i++)); do
        bar+="░"
    done
    
    echo "$bar"
}

display_costs() {
    local json_data="$1"
    local top_n="$2"
    local start_date="$3"
    local end_date="$4"
    local show_ec2_details="$5"
    local total_cost=0
    
    # Parse and sort services by cost
    local services
    services=$(echo "$json_data" | python3 -c "
import sys
import json

data = json.load(sys.stdin)
services = []

for result in data.get('ResultsByTime', []):
    for group in result.get('Groups', []):
        service_name = group['Keys'][0]
        cost = float(group['Metrics']['UnblendedCost']['Amount'])
        if cost > 0.001:  # Filter out negligible costs
            services.append((service_name, cost))

# Sort by cost descending
services.sort(key=lambda x: x[1], reverse=True)

for name, cost in services:
    print(f'{cost:.4f}|{name}')
" 2>/dev/null)
    
    if [[ -z "$services" ]]; then
        echo -e "${YELLOW}No cost data found for this period${NC}"
        return
    fi
    
    # Calculate total
    total_cost=$(echo "$services" | awk -F'|' '{sum += $1} END {print sum}')
    
    # Print header
    echo ""
    printf "  ${BOLD}%-40s %12s %8s  %-20s${NC}\n" "SERVICE" "COST (USD)" "%" "DISTRIBUTION"
    print_separator
    
    # Print services
    local count=0
    while IFS='|' read -r cost service; do
        if [[ $count -ge $top_n ]]; then
            break
        fi
        
        local percentage
        percentage=$(echo "scale=2; ($cost / $total_cost) * 100" | bc)
        local color
        color=$(color_for_cost "$cost")
        local bar
        bar=$(create_bar "$percentage")
        
        # Store original service name for EC2 check
        local original_service="$service"
        
        # Truncate service name if too long
        if [[ ${#service} -gt 38 ]]; then
            service="${service:0:35}..."
        fi
        
        printf "  %-40s ${color}%12.2f${NC} %7.1f%%  ${BLUE}%s${NC}\n" "$service" "$cost" "$percentage" "$bar"
        
        # Show EC2-Other breakdown (NAT Gateway, EBS, etc.)
        if [[ "$original_service" == "EC2 - Other" ]] && [[ "$show_ec2_details" == true ]]; then
            local ec2_other_data
            ec2_other_data=$(get_ec2_other_breakdown "$start_date" "$end_date")
            display_ec2_breakdown "$ec2_other_data" "$cost" "EC2 Infrastructure Breakdown"
        fi
        
        # Show EC2-Compute breakdown (instances)
        if [[ "$original_service" == "Amazon Elastic Compute Cloud - Compute" ]] && [[ "$show_ec2_details" == true ]]; then
            local ec2_compute_data
            ec2_compute_data=$(get_ec2_compute_breakdown "$start_date" "$end_date")
            display_ec2_breakdown "$ec2_compute_data" "$cost" "EC2 Instances Breakdown"
        fi
        
        ((count++))
    done <<< "$services"
    
    # Show remaining count if there are more services
    local total_services
    total_services=$(echo "$services" | wc -l | tr -d ' ')
    if [[ $total_services -gt $top_n ]]; then
        local remaining=$((total_services - top_n))
        echo -e "  ${DIM}... and $remaining more services${NC}"
    fi
    
    # Print total
    print_separator
    local total_color
    total_color=$(color_for_cost "$total_cost")
    printf "  ${BOLD}%-40s${NC} ${total_color}${BOLD}%12.2f${NC}\n" "TOTAL" "$total_cost"
}

display_forecast() {
    local forecast_json="$1"
    
    if [[ -z "$forecast_json" ]] || [[ "$forecast_json" == "null" ]]; then
        echo -e "  ${YELLOW}Forecast unavailable${NC}"
        return
    fi
    
    local forecast_amount
    forecast_amount=$(echo "$forecast_json" | python3 -c "
import sys
import json
data = json.load(sys.stdin)
total = data.get('Total', {})
amount = total.get('Amount', '0')
print(f'{float(amount):.2f}')
" 2>/dev/null)
    
    local prediction_low
    prediction_low=$(echo "$forecast_json" | python3 -c "
import sys
import json
data = json.load(sys.stdin)
pi = data.get('Total', {}).get('PredictionIntervalLowerBound', '0')
print(f'{float(pi) if pi else 0:.2f}')
" 2>/dev/null)
    
    local prediction_high
    prediction_high=$(echo "$forecast_json" | python3 -c "
import sys
import json
data = json.load(sys.stdin)
pi = data.get('Total', {}).get('PredictionIntervalUpperBound', '0')
print(f'{float(pi) if pi else 0:.2f}')
" 2>/dev/null)
    
    echo ""
    echo -e "  ${BOLD}Month-End Forecast:${NC}"
    local color
    color=$(color_for_cost "$forecast_amount")
    echo -e "  Predicted Total: ${color}${BOLD}\$${forecast_amount}${NC}"
    if [[ "$prediction_low" != "0.00" ]] && [[ "$prediction_high" != "0.00" ]]; then
        echo -e "  ${DIM}Range: \$${prediction_low} - \$${prediction_high}${NC}"
    fi
}

# Main execution
main() {
    local period="month"
    local show_forecast=false
    local show_ec2_details=true
    local top_n=30
    local custom_profile=""
    
    # No args: show help
    if [[ $# -eq 0 ]]; then
        show_help
        exit 0
    fi
    
    # "list" subcommand: show profiles and exit
    if [[ "$1" == "list" ]]; then
        list_profiles
        exit 0
    fi
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -p|--profile)
                custom_profile="$2"
                AWS_PROFILE_OPT="--profile $2"
                shift 2
                ;;
            -m|--mtd)
                period="month"
                shift
                ;;
            -w|--week)
                period="week"
                shift
                ;;
            -y|--yesterday)
                period="yesterday"
                shift
                ;;
            -d|--days)
                period="$2"
                shift 2
                ;;
            -f|--forecast)
                show_forecast=true
                shift
                ;;
            -e|--ec2)
                show_ec2_details=true
                shift
                ;;
            --no-ec2)
                show_ec2_details=false
                shift
                ;;
            -t|--top)
                top_n="$2"
                shift 2
                ;;
            *)
                echo -e "${RED}Unknown option:${NC} $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    # Get current profile and account info
    local profile
    if [[ -n "$custom_profile" ]]; then
        profile="$custom_profile"
    else
        profile=$(get_current_profile)
    fi
    
    echo -e "\n${BOLD}${CYAN}☁ AWS Billing Dashboard${NC}"
    echo ""
    
    echo -e "  ${BOLD}Profile:${NC}     ${YELLOW}$profile${NC}"
    
    local account_info
    account_info=$(get_account_info)
    
    if [[ -z "$account_info" ]]; then
        echo -e "\n  ${RED}✗ Error:${NC} Failed to authenticate with AWS"
        echo -e "  ${DIM}Make sure you have valid credentials for profile '$profile'${NC}"
        echo -e "  ${DIM}Try running 'auth' first to authenticate${NC}\n"
        exit 1
    fi
    
    IFS='|' read -r account_id account_alias <<< "$account_info"
    echo -e "  ${BOLD}Account:${NC}     ${WHITE}$account_id${NC}"
    if [[ -n "$account_alias" ]]; then
        echo -e "  ${BOLD}Alias:${NC}       ${CYAN}$account_alias${NC}"
    fi
    
    # Calculate date range
    local dates
    dates=$(calculate_dates "$period")
    IFS='|' read -r start_date end_date <<< "$dates"
    
    echo -e "  ${BOLD}Period:${NC}      $start_date → $end_date"
    
    print_header "Cost Breakdown by Service"
    
    # Fetch and display costs
    local cost_data
    cost_data=$(get_costs_by_service "$start_date" "$end_date")
    
    if [[ -z "$cost_data" ]]; then
        echo -e "\n  ${RED}✗ Error:${NC} Failed to fetch cost data"
        echo -e "  ${DIM}Make sure Cost Explorer is enabled in your account${NC}\n"
        exit 1
    fi
    
    display_costs "$cost_data" "$top_n" "$start_date" "$end_date" "$show_ec2_details"
    
    # Show forecast if requested
    if [[ "$show_forecast" == true ]]; then
        print_header "Forecast"
        local forecast_data
        forecast_data=$(get_forecast)
        display_forecast "$forecast_data"
    fi
    
    echo ""
}

main "$@"
